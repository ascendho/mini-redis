## 8b. Hashtables (Part 2)

### 1. 哈希函数选择

- **分类**：
  - 加密哈希函数（MD5、SHA1）：安全但慢，不适合哈希表
  - 校验和哈希函数（CRC32、Adler32）：用于数据完整性检查
  - **哈希表专用函数（FNV、Murmur）**：速度快，分布均匀，适合哈希表
- **选择原则**：根据用途选择，不要混用不同类型的哈希函数

### 2. 侵入式链表节点定义
```c
struct HNode {
    HNode *next = NULL;
    uint64_t hcode = 0;    // 存储键的哈希值
};
```
- 节点本身不包含数据，只包含哈希值和下一个节点指针

### 3. 固定大小哈希表结构
```c
struct HTab {
    HNode **tab = NULL;    // 槽位数组（指针数组）
    size_t mask = 0;       // 掩码（2^n - 1）
    size_t size = 0;       // 键的数量
};
```
- **优化技巧**：使用2的幂作为数组大小，用位与操作代替取模：`hash(key) & mask`

### 4. 核心操作实现
- **初始化**：分配槽位数组，设置掩码
- **插入**：计算槽位，插入到链表头部（O(1)）
- **查找**：返回**指向目标指针的地址**（而非节点本身），便于删除操作
- **删除**：通过修改父指针来移除节点，无需特殊处理头节点

### 5. 链表设计的精妙之处
- **统一处理**：无论是数组槽位还是节点中的`next`指针，都视为"指向目标的指针"
- **无特殊情况**：删除头节点与删除中间节点使用相同的逻辑
- **返回指针的指针**：`h_lookup`返回`HNode**`，使得删除操作可以直接修改父指针

---

## 二、可调整大小的哈希表（渐进式重新哈希）

### 1. 哈希表管理结构
```c
struct HMap {
    HTab newer;           // 新表（当前使用）
    HTab older;           // 旧表（迁移中）
    size_t migrate_pos = 0; // 当前迁移的槽位位置
};
```

### 2. 渐进式重新哈希流程
1. **触发条件**：当新表的负载因子超过阈值时（如8.0）
2. **初始化新表**：大小为旧表的2倍（保持2的幂）
3. **逐步迁移**：每次操作迁移固定数量的键（如128个）
4. **查询双表**：在迁移期间，查询需要检查新旧两个表

### 3. 关键操作实现
- **插入**：总是插入到新表，可能触发重新哈希
- **查找/删除**：先检查新表，再检查旧表，同时帮助迁移
- **迁移帮助函数**：扫描旧表槽位，逐个迁移链表节点

### 4. 负载因子设置
```c
const size_t k_max_load_factor = 8;    // 链式哈希表可接受较高负载
```
- 链式哈希表每个槽位可存储多个键值对，负载因子可大于1

---

## 三、Redis命令的具体实现

### 1. 数据模型定义
```c
struct Entry {
    struct HNode node;    // 嵌入的哈希表节点
    std::string key;
    std::string val;
};

static struct {
    HMap db;    // 顶层哈希表
} g_data;
```

### 2. 相等比较函数
```c
static bool entry_eq(HNode *lhs, HNode *rhs) {
    struct Entry *le = container_of(lhs, struct Entry, node);
    struct Entry *re = container_of(rhs, struct Entry, node);
    return le->key == re->key;
}
```
- 使用`container_of`宏从节点指针获取完整的数据结构

### 3. 命令实现模式
- **查找键**：创建临时键结构进行查找
- **哈希计算**：对键字符串计算哈希值
- **容器操作**：通过`container_of`从节点获取完整数据

### 4. 查找优化
- 可以定义专门的查找键结构，减少临时对象开销
- 支持多种键类型，只要嵌入`HNode`并实现相等比较函数

---

## 四、技术要点总结

### 1. 设计哲学
- **避免特殊情况**：通过指针间接寻址统一处理各种情况
- **渐进式优化**：大操作分解为小步骤，避免服务中断
- **性能与简洁平衡**：在保证性能的同时保持代码可读性

### 2. 实现技巧
- **位操作优化**：用`&`代替`%`进行取模运算
- **惰性初始化**：使用`calloc`避免立即清零大数组
- **统一接口**：查找返回指针的指针，简化删除操作

### 3. 工程实践价值
- **适用于系统编程**：低层次控制内存管理和性能优化
- **可扩展性强**：侵入式设计支持多索引和复杂数据结构
- **生产环境验证**：类似Linux内核的数据结构设计思路

---

这个实现展示了如何从零构建一个生产级别的哈希表，特别注重**最坏情况性能**和**渐进式操作**，这些都是Redis这类高性能系统必须考虑的关键因素。