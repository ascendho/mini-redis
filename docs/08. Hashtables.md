## 08. Hashtables

### 1. 键值存储的数据结构分类

- **排序数据结构**（如 AVL 树、B 树、Trie）：保持键的顺序，查找复杂度为 \(O(\log N)\)。
- **哈希表**：不保持顺序，通过哈希函数实现平均 \(O(1)\) 的查找复杂度。
  - **开放寻址法**：键值对直接存储在数组中，冲突时通过探测（如线性探测）寻找空位。
  - **链式法**：每个槽位是一个链表（或其他容器），冲突的键值对存储在同一个槽位的链表中。

### 2. 哈希表的基本原理

- 将任意类型的键通过哈希函数映射为整数，再取模得到数组索引。
- 冲突处理：多个键映射到同一索引时，需在槽位内进行二次查找（如遍历链表）。

### 3. 哈希函数的重要性

- 即使键已经是整数，也需要哈希函数来避免分布不均（如指针对齐导致的槽位浪费）。
- 好的哈希函数能减少冲突，避免最坏情况下的 \(O(N)\) 查找。

---

## 二、Redis 中的哈希表设计考虑

### 1. 为什么不用 STL 的 `std::unordered_map`？
- **吞吐量 vs 延迟**：STL 优化的是平均吞吐量，而 Redis 需要保证低延迟。
- **最坏情况下的延迟问题**：
  - 插入可能触发全量 rehash，导致 \(O(N)\) 的延迟，在大内存环境下不可接受。

### 2. 渐进式重新哈希

- **解决方案**：不一次性迁移所有键，而是分批迁移。
- 在 rehash 期间，查询需要同时检查新旧两个哈希表。
- 使用 `calloc()` 而非 `malloc() + memset()` 来避免初始化大数组的延迟（`calloc` 支持惰性零初始化）。

### 3. 为什么选择链式哈希表？
- **抗冲突能力强**：冲突键共享同一槽位，不影响其他槽位。
- **插入/删除快**：链表插入删除为 \(O(1)\)。
- **引用稳定性**：键值对的指针在 rehash 后仍然有效。
- **可实现为侵入式数据结构**，更灵活。

---

## 三、C 语言中的通用数据结构实现

### 1. 传统方法的缺点
- **`void*` 指针**：需要额外内存分配、类型不安全、访问需间接寻址。
- **宏或代码生成器**：类似 C++ 模板，但代码难以调试和维护。

### 2. 侵入式数据结构（Intrusive Data Structures）
- **核心思想**：将数据结构节点（如 `Node`）嵌入到用户数据结构中，而不是封装用户数据。
- **示例**：
  
  ```c
  struct Node {
      Node *next;
  };
  struct MyData {
      int foo;
      Node node;  // 嵌入的链表节点
  };
  ```

### 3. `container_of` 宏
- 用于从嵌入的节点指针反推出外层数据结构的指针。
- 示例：
  ```c
  #define container_of(ptr, T, member) \
      ((T*)((char*)ptr - offsetof(T, member)))
  ```
- Linux 内核中常用，支持类型检查。

### 4. 侵入式数据结构的优势

- **无额外内存分配**：节点借用用户数据的内存。
- **无间接访问**：直接访问数据，性能高。
- **支持多索引**：一个数据节点可同时属于多个数据结构（如哈希表和树）。
- **支持异构数据类型**：同一集合可存储不同类型的数据。

---

## 四、总结

- **哈希表选择**：Redis 选择链式哈希表，因其简单、稳定、适合高并发和低延迟场景。
- **渐进式 rehash**：解决大哈希表重新哈希时的延迟问题。
- **侵入式数据结构**：是 C 语言中实现通用、高效数据结构的最佳实践，尤其适合系统级编程。
