## 10. Balanced Binary Tree

### 1. 有序集合（Sorted Set）基础

- 本质是（分数score，名称name）键值对集合，支持排序功能，适用于排行榜、有序数据存储等场景。
- 排序规则：先按score升序排列，score相等时按name（字节字符串）升序排列，可通过编码保留任意数据的排序逻辑。
- 双索引设计：通过`by_score`（按分数排序的集合）和`by_name`（按名称查询的哈希表）实现高效查询，对应数据库中的主键索引（name）和二级索引（score+name）。
- 底层排序结构：Redis实际使用跳表，本文选择更易实现的AVL树，STL的set/map则基于红黑树。



### 2. 树结构分类与对比

#### 2.1 核心分类

- 不平衡二叉树：插入顺序影响树形，最坏情况退化为链表（查询复杂度O(N)），平均复杂度O(logN)。
- 平衡二叉树：通过维护 invariants 限制树深度，最坏情况仍保障O(logN)操作效率，常见类型包括：
  - AVL树：左右子树高度差最大为1，实现简单（中等难度）。
  - 红黑树：叶子节点高度差不超过2倍，实现复杂（高难度）。
  - B树：N叉树，所有叶子节点高度一致，适用于磁盘存储（高难度）。
  - 跳表：本质是N叉树，依赖随机性，Redis实际采用（中等难度）。
  - 树堆（Treap）：通过随机旋转调整树形，无最坏情况保障（低难度）。

#### 2.2 关键特性对比

| 树结构   | 最坏时间复杂度 | 分支数 | 依赖随机性 | 实现难度 |
|----------|----------------|--------|------------|----------|
| AVL树    | O(logN)        | 2      | 否         | 中等     |
| 红黑树   | O(logN)        | 2      | 否         | 高       |
| B树      | O(logN)        | n      | 否         | 高       |
| 跳表     | O(N)           | n      | 是         | 中等     |
| 树堆     | O(N)           | 2      | 是         | 低       |



### 3. 二叉树基础操作

#### 3.1 搜索与插入

- 核心逻辑：从根节点出发，通过比较函数确定目标在左/右子树，递归遍历直至空节点（插入位置）或找到目标节点（查询命中）。
- 插入实现：利用“传入指针技巧”，返回目标节点的指针地址，空地址直接挂载新节点，支持侵入式数据结构（节点包含数据本身）。

#### 3.2 节点删除

- 简单情况：节点无子女或仅1个子女，直接用子女替换该节点。
- 复杂情况：节点有2个子女，找到右子树最左节点（后继节点），交换目标节点与后继节点，再按简单情况删除原目标节点（后继节点必无左子女）。
- 无父指针设计：通过递归实现删除后父节点与新子树的链接。

#### 3.3 有序遍历

- 依赖后继节点查找：右子树非空时取右子树最左节点，右子树为空时需回溯（通常需父指针，无父指针则需存储节点路径）。



### 4. AVL树核心原理

#### 4.1 平衡不变量

- 定义：任意节点的左右子树高度差（平衡因子）不超过1，子树高度为根节点到叶子节点的最大距离（空树高度为0）。
- 失衡触发：插入/删除操作可能导致子树高度变化，使平衡因子达到2，需通过旋转修复。

#### 4.2 旋转操作（保持排序性）

旋转是调整树形、修复失衡的核心，不改变数据排序顺序，仅调整节点父子关系。
- 左旋转：将节点的右子女提升为新根，原右子女的左子树作为原节点的右子树，更新父指针和高度。
- 右旋转：将节点的左子女提升为新根，原左子女的右子树作为原节点的左子树，更新父指针和高度。

#### 4.3 失衡修复场景

- 左子树过高（平衡因子=2）：
  1. 左-左型（左子树的左子树更高）：直接右旋转修复。
  2. 左-右型（左子树的右子树更高）：先对左子树左旋转，转为左-左型，再右旋转修复。
- 右子树过高（平衡因子=-2）：
  1. 右-右型（右子树的右子树更高）：直接左旋转修复。
  2. 右-左型（右子树的左子树更高）：先对右子树右旋转，转为右-右型，再左旋转修复。
  
  

### 5. AVL树实现步骤

#### 5.1 节点结构设计

```cpp
struct AVLNode {
    AVLNode *parent = NULL;  // 父指针，简化操作
    AVLNode *left = NULL;
    AVLNode *right = NULL;
    uint32_t height = 0;     // 子树高度，避免重复计算
};
```
- 初始化：节点初始高度为1，父子指针为空。
- 高度更新：通过`avl_update`函数，基于左右子树高度计算当前节点高度（1+max(左高, 右高)）。

#### 5.2 核心函数实现

- 旋转函数（rot_left/rot_right）：处理节点父子关系调整，更新父指针和高度。
- 失衡修复函数（avl_fix_left/avl_fix_right）：根据失衡类型执行旋转，修复平衡因子。
- 平衡传播函数（avl_fix）：从操作节点向上遍历至根，更新高度并修复沿途失衡，返回新根节点。
- 删除函数（avl_del）：区分简单/复杂删除场景，调用`avl_del_easy`处理后继节点交换，自动触发平衡修复。

#### 5.3 对外API

- 插入：`search_and_insert`找到插入位置，挂载新节点后调用`avl_fix`修复平衡。
- 删除：`search_and_delete`找到目标节点，调用`avl_del`删除并返回新根。
- 核心特点：无需通用比较回调，自定义搜索函数更灵活高效。



### 6. 测试建议

- 自动生成测试用例，覆盖插入、删除、遍历等场景。
- 验证 invariants：确保所有节点平衡因子不超过1，高度计算正确。
- 与参考结构对比：将结果与std::set比对，保障功能正确性。
