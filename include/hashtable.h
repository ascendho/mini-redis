#pragma once

#include <cstdint>

/*
 * hcode 采用64位无符号整数，而非内部直接取余或掩码运算的原因：
 * 1. 保证哈希值分布特性
 *    哈希函数需将任意输入（字符串、对象等）映射到大范围整数，
 *    以满足均匀性（避免哈希值聚集）和雪崩效应（输入微小变化导致哈希值剧烈变化），
 *    直接截断会破坏这些特性，导致后续索引分布密集、冲突率升高。
 *
 * 2. 与哈希表大小解耦，支持动态扩容
 *    哈希表大小 N 会动态变化（如扩容），若 hcode 内部依赖 N 计算，
 *    则每次扩容需重新计算所有哈希值，且同一输入在不同 N 下会产生不同 hcode，
 *    失去通用性和稳定性。
 *
 * 3. 适配多样化的索引映射策略
 *    “计算哈希值”与“映射到索引”是独立步骤，64位 hcode 可灵活适配不同哈希表实现：
 *    - 普通哈希表：用 hcode & mask 或 hcode % N 映射索引；
 *    - 开放寻址法：需二次探测等复杂计算（如 (hcode + i²) % N）；
 *    - 分布式哈希：映射到环形空间（0~2³²-1）等场景。
 *
 */

// 哈希表节点（需嵌入到用户数据结构中）
struct HNode {
    HNode *next = nullptr;
    uint64_t hcode = 0;
};

/*
 * 哈希表掩码（mask）计算索引的示例与优势说明
 * 1. 示例参数定义
 *    - 哈希表容量 N = 8（需为2的幂）
 *    - 掩码 mask = N - 1 = 7，二进制表示为 0b111
 *    - 某节点哈希值 hcode = 25，二进制表示为 0b11001
 *
 * 2. 掩码计算索引过程（hcode & mask）
 *    - 计算公式：hcode & mask = 25 & 7
 *    - 二进制底层运算：0b11001（25） & 0b00111（7） = 0b00001（1）
 *    - 计算结果：索引值为 1
 *
 * 3. 与取模运算（hcode % N）的对比
 *    - 取模计算公式：hcode % N = 25 % 8
 *    - 取模结果：1（与掩码计算结果完全一致）
 *
 * 4. 优先使用掩码计算的原因
 *    - 1. 性能更优：位运算（&）是计算机硬件直接支持的基础操作，执行速度远快于取模运算（%）
 *    - 2. 索引安全：mask 二进制为“全1”形式（如7对应 0b111），
 *                 hcode & mask 的结果必然落在 0～mask（即 0～N-1）范围内，
 *                 刚好匹配哈希桶数组的索引区间，不会出现索引越界问题
 *
 */

// 固定大小的哈希表（内部实现，用户不直接操作）
struct HTab {
    HNode **tab = nullptr;  // 哈希桶数组
    size_t mask = 0;        // 索引掩码（用于快速计算索引，mask+1 等于哈希表容量）
    size_t size = 0;        // 当前表中存储的节点总数
};

/*
 * tab 被定义为 HNode**（指针的指针），其本质是用于表示一个「哈希桶数组」：
 *   - 该数组的每个元素（哈希桶）是一个指针（HNode* 类型），指向对应链表的头部节点；
 *   - 因此，整个哈希桶数组的类型可视为 HNode*[]（存储 HNode* 元素的数组）。
 *
 * 具体来说：
 *   - tab 作为 HNode** 类型，存储的是「哈希桶数组的首地址」（即数组在内存中的起始位置）；
 *   - 数组中的元素（如 tab[0]）为 HNode* 类型，指向第 0 号哈希桶对应的链表头部；
 *   - 若某哈希桶为空（无节点），则对应的数组元素（如 tab[pos]）为 nullptr。
 *
 * 注：
 * `*tab` 与 `tab[0]` 等价，原因如下：
 *   1. 数组访问符 `[]` 本质是指针算术的语法糖，
 *      即 `a[0]` 等价于 `*(a + 0)`（指针 `a` 偏移 0 个元素后解引用）。
 *   2. 对于 `HNode **tab` 而言，
 *      两者均表示哈希桶数组的第一个元素，
 *      即第一个哈希桶对应的链表头指针（`HNode *` 类型）。
 *
 */

// 哈希表对外接口（封装渐进式重哈希逻辑）
struct HMap {
    HTab newer;
    HTab older;
    size_t migrate_pos = 0;
};

HNode *hm_lookup(HMap *hmap, HNode *key, bool (*eq)(HNode *, HNode *));

void hm_insert(HMap *hmap, HNode *node);

HNode *hm_delete(HMap *hmap, HNode *key, bool (*eq)(HNode *, HNode *));

void hm_clear(HMap *hmap);

size_t hm_size(const HMap *hmap);
